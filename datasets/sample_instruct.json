[
  {
    "prompt": "Explain what a Python decorator is",
    "response": "A Python decorator is a function that modifies the behavior of another function or class. It's denoted with the @ symbol placed above a function definition. Decorators allow you to wrap another function to extend its behavior without permanently modifying it.\n\nExample:\n```python\ndef my_decorator(func):\n    def wrapper():\n        print(\"Before function call\")\n        func()\n        print(\"After function call\")\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    print(\"Hello!\")\n```"
  },
  {
    "prompt": "Write a function to reverse a string",
    "response": "Here's a simple function to reverse a string in Python:\n\n```python\ndef reverse_string(s):\n    return s[::-1]\n\n# Usage\ntext = \"Hello, World!\"\nreversed_text = reverse_string(text)\nprint(reversed_text)  # Output: !dlroW ,olleH\n```\n\nThis uses Python's slice notation with a step of -1 to reverse the string efficiently."
  },
  {
    "prompt": "What is the difference between a list and a tuple in Python?",
    "response": "The main differences between lists and tuples in Python:\n\n**Lists:**\n- Mutable (can be changed after creation)\n- Use square brackets: [1, 2, 3]\n- Can add, remove, or modify elements\n- Slower due to mutability overhead\n- Used when data will change\n\n**Tuples:**\n- Immutable (cannot be changed after creation)\n- Use parentheses: (1, 2, 3)\n- Cannot modify elements once created\n- Faster and more memory-efficient\n- Used for fixed collections of data\n\nExample:\n```python\nmy_list = [1, 2, 3]\nmy_list[0] = 10  # OK\n\nmy_tuple = (1, 2, 3)\nmy_tuple[0] = 10  # Error! Tuples are immutable\n```"
  },
  {
    "prompt": "Explain recursion with an example",
    "response": "Recursion is when a function calls itself to solve a problem by breaking it down into smaller subproblems. Every recursive function needs:\n1. A base case (stopping condition)\n2. A recursive case (function calling itself)\n\nExample - Factorial:\n```python\ndef factorial(n):\n    # Base case\n    if n == 0 or n == 1:\n        return 1\n    # Recursive case\n    return n * factorial(n - 1)\n\nprint(factorial(5))  # Output: 120\n# Calculation: 5 * 4 * 3 * 2 * 1 = 120\n```"
  },
  {
    "prompt": "How do you handle exceptions in Python?",
    "response": "Python uses try-except blocks to handle exceptions (errors) gracefully:\n\n```python\ntry:\n    # Code that might raise an exception\n    result = 10 / 0\nexcept ZeroDivisionError:\n    # Handle specific exception\n    print(\"Cannot divide by zero!\")\nexcept Exception as e:\n    # Handle any other exception\n    print(f\"An error occurred: {e}\")\nelse:\n    # Runs if no exception occurred\n    print(\"Operation successful\")\nfinally:\n    # Always runs, whether exception occurred or not\n    print(\"Cleanup code here\")\n```\n\nBest practices:\n- Catch specific exceptions, not generic ones\n- Don't use bare except clauses\n- Use finally for cleanup (closing files, connections)"
  },
  {
    "prompt": "What are list comprehensions in Python?",
    "response": "List comprehensions provide a concise way to create lists based on existing lists or other iterables.\n\nBasic syntax:\n```python\nnew_list = [expression for item in iterable if condition]\n```\n\nExamples:\n```python\n# Square numbers\nsquares = [x**2 for x in range(10)]\n# Result: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n# Filter even numbers\nevens = [x for x in range(20) if x % 2 == 0]\n# Result: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n\n# Transform strings\nwords = ['hello', 'world']\nupper_words = [word.upper() for word in words]\n# Result: ['HELLO', 'WORLD']\n```\n\nList comprehensions are more concise and often faster than traditional loops."
  },
  {
    "prompt": "Explain the difference between == and is in Python",
    "response": "**== (equality operator):**\n- Compares the VALUES of two objects\n- Returns True if values are equal\n\n**is (identity operator):**\n- Compares the IDENTITY (memory location) of two objects\n- Returns True if both variables point to the same object\n\nExample:\n```python\na = [1, 2, 3]\nb = [1, 2, 3]\nc = a\n\nprint(a == b)  # True (same values)\nprint(a is b)  # False (different objects in memory)\nprint(a is c)  # True (same object)\n```\n\nUse == for value comparison and is for checking if two variables refer to the exact same object (commonly used with None):\n```python\nif value is None:\n    print(\"Value is None\")\n```"
  },
  {
    "prompt": "What is a lambda function?",
    "response": "A lambda function is a small anonymous function defined with the lambda keyword. It can take any number of arguments but can only have one expression.\n\nSyntax:\n```python\nlambda arguments: expression\n```\n\nExamples:\n```python\n# Regular function\ndef add(x, y):\n    return x + y\n\n# Equivalent lambda\nadd_lambda = lambda x, y: x + y\n\nprint(add_lambda(5, 3))  # Output: 8\n\n# Common use with map, filter, sorted\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x**2, numbers))\n# Result: [1, 4, 9, 16, 25]\n\n# Sorting with key\npeople = [('Alice', 25), ('Bob', 30), ('Charlie', 20)]\nsorted_by_age = sorted(people, key=lambda x: x[1])\n# Result: [('Charlie', 20), ('Alice', 25), ('Bob', 30)]\n```"
  },
  {
    "prompt": "How do you read and write files in Python?",
    "response": "Python provides several ways to work with files. The recommended approach uses the `with` statement:\n\n**Reading files:**\n```python\n# Read entire file\nwith open('file.txt', 'r') as f:\n    content = f.read()\n\n# Read line by line\nwith open('file.txt', 'r') as f:\n    for line in f:\n        print(line.strip())\n\n# Read all lines into a list\nwith open('file.txt', 'r') as f:\n    lines = f.readlines()\n```\n\n**Writing files:**\n```python\n# Write (overwrites existing file)\nwith open('file.txt', 'w') as f:\n    f.write('Hello, World!\\n')\n\n# Append (adds to existing file)\nwith open('file.txt', 'a') as f:\n    f.write('New line\\n')\n\n# Write multiple lines\nlines = ['Line 1\\n', 'Line 2\\n', 'Line 3\\n']\nwith open('file.txt', 'w') as f:\n    f.writelines(lines)\n```\n\nThe `with` statement automatically closes the file, even if an error occurs."
  },
  {
    "prompt": "What are Python virtual environments and why use them?",
    "response": "A virtual environment is an isolated Python environment that lets you install packages independently for different projects.\n\n**Why use them:**\n- Avoid dependency conflicts between projects\n- Keep project dependencies organized\n- Reproducible environments\n- Cleaner system Python installation\n\n**Creating and using virtual environments:**\n\n```bash\n# Create virtual environment\npython -m venv myenv\n\n# Activate (Linux/Mac)\nsource myenv/bin/activate\n\n# Activate (Windows)\nmyenv\\Scripts\\activate\n\n# Install packages\npip install requests pandas\n\n# Save dependencies\npip freeze > requirements.txt\n\n# Install from requirements\npip install -r requirements.txt\n\n# Deactivate\ndeactivate\n```\n\nEach project should have its own virtual environment to maintain independence."
  },
  {
    "prompt": "Explain Python's GIL (Global Interpreter Lock)",
    "response": "The Global Interpreter Lock (GIL) is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecode simultaneously.\n\n**Key points:**\n- Only one thread can execute Python code at a time\n- Affects CPU-bound multi-threaded programs\n- Doesn't affect I/O-bound programs much\n- Doesn't prevent multi-processing\n\n**Implications:**\n```python\n# Multi-threading (limited by GIL)\nimport threading\n\ndef cpu_task():\n    total = sum(range(10000000))\n\nthreads = [threading.Thread(target=cpu_task) for _ in range(4)]\n# Won't use 4 CPU cores efficiently due to GIL\n\n# Multi-processing (bypasses GIL)\nimport multiprocessing\n\ndef cpu_task():\n    return sum(range(10000000))\n\nwith multiprocessing.Pool(4) as pool:\n    results = pool.map(cpu_task, range(4))\n# Uses 4 CPU cores efficiently\n```\n\n**When to use:**\n- Threading: I/O-bound tasks (file operations, network requests)\n- Multiprocessing: CPU-bound tasks (computations, data processing)"
  },
  {
    "prompt": "What is the difference between shallow copy and deep copy?",
    "response": "**Shallow Copy:**\n- Creates a new object, but copies references to nested objects\n- Changes to nested objects affect both copies\n- Created with `copy.copy()` or slice `[:]`\n\n**Deep Copy:**\n- Creates a completely independent copy\n- Recursively copies all nested objects\n- Created with `copy.deepcopy()`\n\nExample:\n```python\nimport copy\n\n# Original list with nested list\noriginal = [[1, 2, 3], [4, 5, 6]]\n\n# Shallow copy\nshallow = copy.copy(original)\nshallow[0][0] = 999\nprint(original)  # [[999, 2, 3], [4, 5, 6]]  # CHANGED!\nprint(shallow)   # [[999, 2, 3], [4, 5, 6]]\n\n# Deep copy\noriginal = [[1, 2, 3], [4, 5, 6]]\ndeep = copy.deepcopy(original)\ndeep[0][0] = 999\nprint(original)  # [[1, 2, 3], [4, 5, 6]]    # UNCHANGED\nprint(deep)      # [[999, 2, 3], [4, 5, 6]]\n```\n\nUse shallow copy for simple objects, deep copy for complex nested structures."
  },
  {
    "prompt": "How do you work with JSON in Python?",
    "response": "Python's `json` module provides functions to work with JSON data.\n\n**Loading JSON (parsing):**\n```python\nimport json\n\n# From string\njson_string = '{\"name\": \"Alice\", \"age\": 30}'\ndata = json.loads(json_string)\nprint(data['name'])  # Alice\n\n# From file\nwith open('data.json', 'r') as f:\n    data = json.load(f)\n```\n\n**Saving JSON (serialization):**\n```python\nimport json\n\ndata = {\n    'name': 'Alice',\n    'age': 30,\n    'skills': ['Python', 'JavaScript']\n}\n\n# To string\njson_string = json.dumps(data, indent=2)\nprint(json_string)\n\n# To file\nwith open('output.json', 'w') as f:\n    json.dump(data, f, indent=2)\n```\n\n**Useful parameters:**\n- `indent=2`: Pretty-print with indentation\n- `sort_keys=True`: Sort dictionary keys\n- `ensure_ascii=False`: Keep non-ASCII characters\n\n**Working with custom objects:**\n```python\nimport json\nfrom datetime import datetime\n\ndef json_serial(obj):\n    if isinstance(obj, datetime):\n        return obj.isoformat()\n    raise TypeError(f\"Type {type(obj)} not serializable\")\n\ndata = {'timestamp': datetime.now()}\njson.dumps(data, default=json_serial)\n```"
  },
  {
    "prompt": "Explain Python's *args and **kwargs",
    "response": "**`*args` (positional arguments):**\n- Allows a function to accept any number of positional arguments\n- Collects arguments as a tuple\n\n**`**kwargs` (keyword arguments):**\n- Allows a function to accept any number of keyword arguments\n- Collects arguments as a dictionary\n\nExamples:\n```python\n# Using *args\ndef sum_all(*args):\n    return sum(args)\n\nprint(sum_all(1, 2, 3, 4, 5))  # 15\nprint(sum_all(10, 20))          # 30\n\n# Using **kwargs\ndef print_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\nprint_info(name=\"Alice\", age=30, city=\"NYC\")\n# Output:\n# name: Alice\n# age: 30\n# city: NYC\n\n# Combining all\ndef flexible_func(required, *args, default=\"value\", **kwargs):\n    print(f\"Required: {required}\")\n    print(f\"Args: {args}\")\n    print(f\"Default: {default}\")\n    print(f\"Kwargs: {kwargs}\")\n\nflexible_func(\"must_have\", 1, 2, 3, default=\"custom\", extra=\"info\")\n```\n\nCommon use cases:\n- Function wrappers and decorators\n- Extending parent class methods\n- Creating flexible APIs"
  },
  {
    "prompt": "What are Python generators and why use them?",
    "response": "Generators are functions that return an iterator using the `yield` keyword. They generate values on-the-fly rather than storing them all in memory.\n\n**Benefits:**\n- Memory efficient (don't store entire sequence)\n- Can represent infinite sequences\n- Lazy evaluation (compute only when needed)\n\n**Basic example:**\n```python\n# Regular function (returns list)\ndef squares_list(n):\n    result = []\n    for i in range(n):\n        result.append(i**2)\n    return result\n\n# Generator (yields values one at a time)\ndef squares_generator(n):\n    for i in range(n):\n        yield i**2\n\n# Usage\nfor square in squares_generator(5):\n    print(square)  # 0, 1, 4, 9, 16\n```\n\n**Generator expressions:**\n```python\n# Like list comprehension but with ()\nsquares = (x**2 for x in range(1000000))\n# Very memory efficient!\n\n# Use with next()\ngen = (x**2 for x in range(5))\nprint(next(gen))  # 0\nprint(next(gen))  # 1\n```\n\n**Real-world example:**\n```python\ndef read_large_file(file_path):\n    with open(file_path, 'r') as f:\n        for line in f:\n            yield line.strip()\n\n# Process huge file without loading it all into memory\nfor line in read_large_file('huge_file.txt'):\n    process(line)\n```"
  },
  {
    "prompt": "How do you create a class in Python?",
    "response": "Classes in Python are defined using the `class` keyword. Here's a comprehensive example:\n\n```python\nclass Person:\n    # Class variable (shared by all instances)\n    species = \"Homo sapiens\"\n    \n    # Constructor\n    def __init__(self, name, age):\n        # Instance variables (unique to each instance)\n        self.name = name\n        self.age = age\n    \n    # Instance method\n    def greet(self):\n        return f\"Hello, I'm {self.name} and I'm {self.age} years old\"\n    \n    # String representation\n    def __str__(self):\n        return f\"Person({self.name}, {self.age})\"\n    \n    # Class method\n    @classmethod\n    def from_birth_year(cls, name, birth_year):\n        age = 2024 - birth_year\n        return cls(name, age)\n    \n    # Static method\n    @staticmethod\n    def is_adult(age):\n        return age >= 18\n\n# Creating instances\nalice = Person(\"Alice\", 30)\nbob = Person.from_birth_year(\"Bob\", 1990)\n\n# Using methods\nprint(alice.greet())  # Hello, I'm Alice and I'm 30 years old\nprint(Person.is_adult(16))  # False\nprint(alice.species)  # Homo sapiens\n```\n\n**Inheritance:**\n```python\nclass Student(Person):\n    def __init__(self, name, age, student_id):\n        super().__init__(name, age)\n        self.student_id = student_id\n    \n    def greet(self):\n        return f\"{super().greet()}. My student ID is {self.student_id}\"\n\nstudent = Student(\"Charlie\", 20, \"S12345\")\nprint(student.greet())\n```"
  },
  {
    "prompt": "What are Python context managers?",
    "response": "Context managers allow you to allocate and release resources precisely when you want. They're commonly used with the `with` statement.\n\n**Built-in example (file handling):**\n```python\n# With context manager (recommended)\nwith open('file.txt', 'r') as f:\n    content = f.read()\n# File automatically closed, even if error occurs\n\n# Without context manager (manual)\nf = open('file.txt', 'r')\ntry:\n    content = f.read()\nfinally:\n    f.close()  # Must manually close\n```\n\n**Creating custom context managers:**\n\n**Method 1: Class-based**\n```python\nclass DatabaseConnection:\n    def __init__(self, host):\n        self.host = host\n    \n    def __enter__(self):\n        print(f\"Connecting to {self.host}\")\n        # Return resource\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print(f\"Closing connection to {self.host}\")\n        # Return False to propagate exceptions\n        return False\n    \n    def query(self, sql):\n        return f\"Executing: {sql}\"\n\nwith DatabaseConnection(\"localhost\") as db:\n    result = db.query(\"SELECT * FROM users\")\n    print(result)\n```\n\n**Method 2: Using contextlib**\n```python\nfrom contextlib import contextmanager\n\n@contextmanager\ndef timer():\n    import time\n    start = time.time()\n    yield\n    end = time.time()\n    print(f\"Elapsed time: {end - start:.2f}s\")\n\nwith timer():\n    # Your code here\n    sum(range(1000000))\n```\n\nContext managers ensure resources are properly cleaned up, making code more robust and readable."
  },
  {
    "prompt": "Explain list slicing in Python",
    "response": "List slicing allows you to extract portions of a list using the syntax `list[start:stop:step]`.\n\n**Basic syntax:**\n```python\nlist[start:stop]  # Items from start to stop-1\nlist[start:]      # Items from start to end\nlist[:stop]       # Items from beginning to stop-1\nlist[:]           # All items (shallow copy)\nlist[::step]      # Every step-th item\n```\n\n**Examples:**\n```python\nnumbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# Basic slicing\nprint(numbers[2:5])    # [2, 3, 4]\nprint(numbers[:4])     # [0, 1, 2, 3]\nprint(numbers[6:])     # [6, 7, 8, 9]\nprint(numbers[:])      # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# With step\nprint(numbers[::2])    # [0, 2, 4, 6, 8]  (every 2nd item)\nprint(numbers[1::2])   # [1, 3, 5, 7, 9]  (every 2nd, starting at 1)\nprint(numbers[::3])    # [0, 3, 6, 9]     (every 3rd item)\n\n# Negative indices\nprint(numbers[-3:])    # [7, 8, 9]  (last 3 items)\nprint(numbers[:-2])    # [0, 1, 2, 3, 4, 5, 6, 7]  (all except last 2)\nprint(numbers[-5:-2])  # [5, 6, 7]  (from -5 to -2)\n\n# Reversing\nprint(numbers[::-1])   # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n```\n\n**Common patterns:**\n```python\n# Copy a list\nnew_list = original_list[:]\n\n# Reverse a list\nreversed_list = original_list[::-1]\n\n# Remove first and last elements\nmiddle = original_list[1:-1]\n\n# Get every other element\nalternate = original_list[::2]\n```\n\nSlicing works with strings, tuples, and other sequences too!"
  },
  {
    "prompt": "What are Python f-strings?",
    "response": "F-strings (formatted string literals) are a modern way to format strings in Python, introduced in Python 3.6. They're prefixed with 'f' or 'F' and allow embedding expressions inside curly braces.\n\n**Basic usage:**\n```python\nname = \"Alice\"\nage = 30\n\n# F-string\ngreeting = f\"Hello, {name}! You are {age} years old.\"\nprint(greeting)  # Hello, Alice! You are 30 years old.\n\n# Old way (for comparison)\ngreeting = \"Hello, {}! You are {} years old.\".format(name, age)\n```\n\n**Expressions and operations:**\n```python\nx = 10\ny = 20\nprint(f\"Sum: {x + y}\")        # Sum: 30\nprint(f\"Product: {x * y}\")     # Product: 200\nprint(f\"Average: {(x + y) / 2}\")  # Average: 15.0\n\n# Function calls\ndef square(n):\n    return n ** 2\nprint(f\"Square of 5: {square(5)}\")  # Square of 5: 25\n```\n\n**Formatting options:**\n```python\n# Decimal places\npi = 3.14159265359\nprint(f\"Pi: {pi:.2f}\")  # Pi: 3.14\nprint(f\"Pi: {pi:.4f}\")  # Pi: 3.1416\n\n# Padding and alignment\nname = \"Alice\"\nprint(f\"|{name:10}|\")   # |Alice     | (left-aligned, width 10)\nprint(f\"|{name:>10}|\")  # |     Alice| (right-aligned)\nprint(f\"|{name:^10}|\")  # |  Alice   | (centered)\n\n# Numbers\nnumber = 1234567\nprint(f\"{number:,}\")     # 1,234,567 (thousands separator)\nprint(f\"{number:e}\")     # 1.234567e+06 (scientific notation)\n\n# Percentages\nratio = 0.875\nprint(f\"{ratio:.1%}\")    # 87.5%\n\n# Date formatting\nfrom datetime import datetime\nnow = datetime.now()\nprint(f\"Date: {now:%Y-%m-%d}\")  # Date: 2024-01-15\nprint(f\"Time: {now:%H:%M:%S}\")  # Time: 14:30:45\n```\n\n**Multi-line f-strings:**\n```python\nname = \"Alice\"\nage = 30\ncity = \"NYC\"\n\ninfo = f\"\"\"\nName: {name}\nAge: {age}\nCity: {city}\n\"\"\"\nprint(info)\n```\n\nF-strings are faster and more readable than older formatting methods!"
  },
  {
    "prompt": "How do you sort in Python?",
    "response": "Python provides two main ways to sort: the `sorted()` function and the `.sort()` method.\n\n**sorted() function:**\n- Returns a new sorted list\n- Works on any iterable\n- Original remains unchanged\n\n```python\nnumbers = [3, 1, 4, 1, 5, 9, 2, 6]\nsorted_numbers = sorted(numbers)\nprint(sorted_numbers)  # [1, 1, 2, 3, 4, 5, 6, 9]\nprint(numbers)         # [3, 1, 4, 1, 5, 9, 2, 6] (unchanged)\n```\n\n**.sort() method:**\n- Sorts list in-place\n- Only works on lists\n- Original is modified\n- Returns None\n\n```python\nnumbers = [3, 1, 4, 1, 5, 9, 2, 6]\nnumbers.sort()\nprint(numbers)  # [1, 1, 2, 3, 4, 5, 6, 9]\n```\n\n**Common parameters:**\n```python\n# Reverse sort\nnumbers = [3, 1, 4, 1, 5]\nsorted_desc = sorted(numbers, reverse=True)\nprint(sorted_desc)  # [5, 4, 3, 1, 1]\n\n# Sort by key function\nwords = ['banana', 'pie', 'Washington', 'book']\n\n# Sort by length\nby_length = sorted(words, key=len)\nprint(by_length)  # ['pie', 'book', 'banana', 'Washington']\n\n# Case-insensitive sort\nby_lower = sorted(words, key=str.lower)\nprint(by_lower)  # ['banana', 'book', 'pie', 'Washington']\n```\n\n**Sorting complex objects:**\n```python\nstudents = [\n    ('Alice', 85),\n    ('Bob', 92),\n    ('Charlie', 78)\n]\n\n# Sort by grade (second element)\nby_grade = sorted(students, key=lambda x: x[1])\nprint(by_grade)\n# [('Charlie', 78), ('Alice', 85), ('Bob', 92)]\n\n# Sort by name\nby_name = sorted(students, key=lambda x: x[0])\nprint(by_name)\n# [('Alice', 85), ('Bob', 92), ('Charlie', 78)]\n```\n\n**Using itemgetter and attrgetter:**\n```python\nfrom operator import itemgetter, attrgetter\n\nstudents = [\n    {'name': 'Alice', 'grade': 85},\n    {'name': 'Bob', 'grade': 92},\n    {'name': 'Charlie', 'grade': 78}\n]\n\n# Sort by grade\nby_grade = sorted(students, key=itemgetter('grade'))\n\nclass Student:\n    def __init__(self, name, grade):\n        self.name = name\n        self.grade = grade\n\nstudents = [Student('Alice', 85), Student('Bob', 92)]\nby_grade = sorted(students, key=attrgetter('grade'))\n```\n\n**Stable sorting:**\nPython's sort is stable, meaning equal elements maintain their relative order."
  }
]
